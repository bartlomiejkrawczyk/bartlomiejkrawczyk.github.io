---
import type { HTMLAttributes } from "astro/types";
import { commands } from "./Commands";
import Icon from "../Icon.astro";
import type { LanguageKey } from "@src/i18n/ui";

const lang = Astro.currentLocale as LanguageKey;

interface Props extends HTMLAttributes<"div"> {}

const { ...props } = Astro.props;
---

<dialog
  id="command-dialog"
  class={`command-line no-print ${props.class ?? ""}`}
  {...props}
>
  <div class="modal">
    <div class="search-bar">
      <div class="search-icon">
        <Icon icon="mag" />
      </div>
      <input
        id="command-input"
        type="text"
        placeholder="Search..."
        autocomplete="off"
      />
    </div>
    <div class="suggestions">
      {
        Object.entries(commands).map(([, cmd]) => {
          return (
            <button id={cmd.id} class="cmd" onclick="" {...props}>
              {cmd.name[lang]}
            </button>
          );
        })
      }
    </div>
  </div>
</dialog>

<style>
  dialog {
    color: var(--gray-200);
    box-shadow: 0 6px 10px color-mix(in srgb, black 10%, transparent);
  }
  dialog.command-line {
    position: fixed;
    top: 35%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10000;
    max-width: 90%;
    max-height: 90%;
    overflow: auto;
    border-radius: 8px;
    border-width: 1px;
    border-color: var(--gray-900);
    background: transparent;
    padding: 0;
  }

  dialog::backdrop {
    background: rgba(0, 0, 0, 0.2);
  }

  .modal {
    background: var(--background);
    padding: 1rem;
    min-width: 380px;
    margin: 0 auto;
  }

  .suggestions .cmd {
    display: block;
    width: 100%;
    padding: 0.5rem 0.75rem;
    text-align: left;
    border: none;
    border-radius: 6px;
    margin: 0.25rem 0;
    cursor: pointer;
  }

  button.cmd.active {
    background-color: var(--gray-950);
    outline: 2px solid var(--secondary-regular);
  }

  .search-bar {
    display: flex;
  }

  .search-icon {
    padding: var(--spacing);
    align-items: center;
    display: flex;
    justify-content: center;
  }

  #command-input {
    padding: var(--spacing);
    flex: 1;
    outline: none;
  }
</style>

<script>
  import type { CommandId } from "./Commands";
  import { commands } from "./Commands";

  const dialog = document.getElementById("command-dialog") as HTMLDialogElement;
  const input = document.getElementById("command-input") as HTMLInputElement;
  const suggestions = dialog.querySelector(".suggestions") as HTMLDivElement;

  const items = (): HTMLButtonElement[] =>
    Array.from(suggestions.querySelectorAll(".cmd")) as HTMLButtonElement[];

  let activeIndex: number = -1;
  let lastInput: "mouse" | "keyboard" = "mouse";
  let mouseIsMoving = false;
  let lastMouseX = 0;
  let lastMouseY = 0;

  // --- Helpers --------------------------------------------------------------

  function highlight(index: number): void {
    const cmds = items();

    cmds.forEach((cmd, i) => {
      if (i === index) cmd.classList.add("active");
      else cmd.classList.remove("active");
    });

    activeIndex = index;
  }

  function move(delta: number): void {
    const cmds = items();
    if (cmds.length === 0) return;

    let next = activeIndex + delta;

    if (next < 0) next = cmds.length - 1;
    if (next >= cmds.length) next = 0;

    highlight(next);
  }

  function selectActive(): void {
    const cmds = items();
    if (activeIndex < 0 || activeIndex >= cmds.length) return;

    const cmd = cmds[activeIndex];

    if (!cmd) return;

    commands[cmd.id as CommandId]?.execute?.();
    dialog.close();
  }

  // --- ESC toggle -----------------------------------------------------------

  document.addEventListener("keydown", (ev: KeyboardEvent): void => {
    if (ev.key === "Escape") {
      ev.preventDefault();

      if (!dialog.open) {
        dialog.showModal();
        input.focus();
      } else {
        dialog.close();
      }
    }

    if (
      (ev.key === "P" || ev.key === "p") &&
      ev.shiftKey &&
      (ev.ctrlKey || ev.metaKey)
    ) {
      ev.preventDefault();
      if (!dialog.open) {
        dialog.showModal();
        input.focus();
      }
    }
  });

  // --- Close when clicking outside -----------------------------------------

  dialog.addEventListener("click", (ev: MouseEvent): void => {
    const modal = dialog.querySelector(".modal") as HTMLDivElement;
    const rect = modal.getBoundingClientRect();

    const outside =
      ev.clientX < rect.left ||
      ev.clientX > rect.right ||
      ev.clientY < rect.top ||
      ev.clientY > rect.bottom;

    if (outside) dialog.close();
  });

  // --- Mouse hover / unhover: highlight item --------------------------------

  suggestions.addEventListener("mouseover", (ev) => {
    const target = ev.target as HTMLElement;
    if (!target.matches(".cmd")) return;

    // Mouse only wins when actually moving
    if (lastInput !== "mouse" || !mouseIsMoving) return;

    const cmds = items();
    const index = cmds.indexOf(target as HTMLButtonElement);
    highlight(index);
  });

  suggestions.addEventListener("mouseout", (ev) => {
    const target = ev.target as HTMLElement;
    if (!target.matches(".cmd")) return;

    // Only clear highlight if mouse is currently the active input
    if (lastInput === "mouse") {
      target.classList.remove("active");
      activeIndex = -1;
    }
  });

  // --- Mouse click select ---------------------------------------------------

  suggestions.addEventListener("click", (ev: MouseEvent): void => {
    const target = ev.target as HTMLElement;
    if (!target.matches(".cmd")) return;

    commands[target.id as CommandId]?.execute?.();
    dialog.close();
  });

  // --- Filter commands live -------------------------------------------------

  function filterCommands() {
    const search = input.value.toLowerCase();

    for (const btn of items()) {
      const name = btn.textContent?.toLowerCase() ?? "";
      btn.style.display = name.includes(search) ? "" : "none";
    }

    const visible = items().filter((b) => b.style.display !== "none");
    if (visible.length > 0) {
      const first = visible[0];
      if (!first) return;
      highlight(items().indexOf(first));
    } else {
      highlight(-1);
    }
  }

  input.addEventListener("input", () => {
    filterCommands();
  });

  // --- Keyboard inside input ------------------------------------------------

  input.addEventListener("keydown", (ev: KeyboardEvent): void => {
    const cmds = items().filter((b) => b.style.display !== "none");

    if (ev.key === "ArrowDown") {
      ev.preventDefault();
      lastInput = "keyboard";
      mouseIsMoving = false;
      if (cmds.length > 0) {
        if (activeIndex === -1) {
          const first = cmds[0];
          if (!first) return;
          highlight(items().indexOf(first));
        } else {
          move(1);
        }
      }
      return;
    }

    if (ev.key === "ArrowUp") {
      ev.preventDefault();
      lastInput = "keyboard";
      mouseIsMoving = false;
      if (cmds.length > 0) {
        if (activeIndex === -1) {
          const last = cmds[cmds.length - 1];
          if (!last) return;
          highlight(items().indexOf(last));
        } else {
          move(-1);
        }
      }
      return;
    }

    if (ev.key === "Enter") {
      ev.preventDefault();
      if (activeIndex >= 0) selectActive();
      return;
    }
  });

  document.addEventListener("mousemove", (ev) => {
    if (ev.clientX !== lastMouseX || ev.clientY !== lastMouseY) {
      mouseIsMoving = true;
      lastInput = "mouse";
      lastMouseX = ev.clientX;
      lastMouseY = ev.clientY;
    }
  });
</script>
