---
import { getCollection } from "astro:content";
import { getRelativeLocaleUrl } from "astro:i18n";
import { getTranslations, type LanguageKey } from "@i18n/ui";
import type { HTMLAttributes } from "astro/types";
import TagElement from "./TagElement.astro";
import { tags } from "@components/content/Tags";

const projects = await getCollection("projects").then((projects) =>
  projects.sort((a, b) => a.id.localeCompare(b.id)),
);

const lang = Astro.currentLocale as LanguageKey;

interface Props extends HTMLAttributes<"div"> {}

const { ...props } = Astro.props;

const t = getTranslations(lang);
---

<div {...props}>
  <h2 id="projects" class="pb-1">{t.projects.header}</h2>
  <!-- https://docs.astro.build/en/guides/content-collections/#filtering-collection-queries -->
  <ul class="projects-ul">
    {
      Object.entries(projects).map(([, project]) => (
        <li class="pt-1 projects-li" data-project-id={project.id}>
          <div class="project-wrapper">
            <div class="flex flex-row items-center">
              <input
                type="checkbox"
                class="project-check styled-checkbox"
                data-project-id={project.id}
                aria-label={`Toggle project ${project.id}`}
              />

              <a
                href={getRelativeLocaleUrl(lang, "/projects/" + project.id)}
                class="full-link"
              >
                <span>
                  <b>{project.data.title ?? project.id}</b>
                </span>
              </a>
            </div>
            <div>{project.data.description}</div>
            <ul class="project-tags">
              {project.data.tags?.map((tag) => (
                <TagElement tag={tags[tag]} />
              ))}
            </ul>
          </div>
        </li>
      ))
    }
  </ul>

  <!-- 
  May configure pagination of projects: 
  https://docs.astro.build/en/guides/routing/#pagination 
  -->
</div>

<style>
  .projects-ul {
    display: grid;
    gap: calc(2 * var(--spacing));
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    grid-auto-rows: auto;
    grid-auto-flow: dense;

    margin: 0;
    padding: 0;
    list-style: none;
  }

  .projects-li {
    display: flex;
    flex-direction: column;
    gap: var(--spacing);
    border: 1px solid var(--gray-900);
    border-radius: var(--radius-lg);
    padding: calc(var(--spacing) * 1.5);
    background-color: var(--background);
    transition:
      transform 1s ease,
      box-shadow 1s ease;
    break-inside: avoid;
  }

  .projects-li:hover,
  .projects-li:focus-within {
    transform: scale(1.01);
    z-index: 10;
    box-shadow: var(--shadow-md);
    transition:
      transform 0.3s ease,
      box-shadow 0.3s ease;
    cursor: pointer;
  }

  .project-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
  }

  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .project-tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing);
  }

  /* TODO: consider using this class along with a button to reveal all tags */
  /* .project-tags li:nth-of-type(1n + 6) {
    display: none;
  } */
  .project-check {
    display: none;
  }

  .project-check.show-in-edit {
    display: inline-block;
    margin-right: 0.5rem;
  }

  .projects-li.hidden {
    display: none !important;
  }

  body.edit-mode .projects-li.hidden {
    display: block !important;
  }

  .styled-checkbox {
    appearance: none;
    width: 1rem;
    height: 1rem;
    border: 2px solid var(--gray-600);
    border-radius: 3px;
    cursor: pointer;
    position: relative;
  }
  .styled-checkbox:checked {
    background-color: var(--primary-light);
    border-color: var(--primary-light);
  }
  .styled-checkbox:checked::before {
    content: "âœ“";
    font-size: 1rem;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
  }
</style>

<script>
  document.querySelectorAll<HTMLDivElement>(".projects-li").forEach((li) => {
    const backgroundArea = li.querySelector(
      ".project-wrapper",
    ) as HTMLDivElement;
    const link = backgroundArea?.querySelector<HTMLAnchorElement>(".full-link");

    if (!backgroundArea || !link) return;

    backgroundArea.addEventListener("click", (ev) => {
      // Prevent clicks on interactive children from triggering navigation
      const interactiveSelectors = "a, button, input";
      if ((ev.target as HTMLElement).closest(interactiveSelectors)) return;

      // Navigate to the link
      window.location.href = link.href;
    });
  });
</script>

<script>
  // ================================
  // Project Edit Mode (Independent)
  // ================================

  const PROJECT_MODE_KEY = "projectEditMode";
  const PROJECT_HIDDEN_KEY = "hiddenProjects";

  // ----------------------------
  // Load/save edit mode
  // ----------------------------
  function loadProjectEditMode() {
    return localStorage.getItem(PROJECT_MODE_KEY) === "true";
  }

  function saveProjectEditMode(enabled: boolean) {
    localStorage.setItem(PROJECT_MODE_KEY, enabled ? "true" : "false");
  }

  // ----------------------------
  // Load/save hidden projects
  // ----------------------------
  function loadHiddenProjects(): Set<string> {
    try {
      const raw = localStorage.getItem(PROJECT_HIDDEN_KEY);
      if (!raw) return new Set();
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return new Set();
      return new Set(arr.map(String));
    } catch {
      return new Set();
    }
  }

  function saveHiddenProjects(set: Set<string>) {
    try {
      localStorage.setItem(PROJECT_HIDDEN_KEY, JSON.stringify([...set]));
    } catch {}
  }

  // ----------------------------
  // Apply state to DOM
  // ----------------------------
  function applyProjectState() {
    const editMode = loadProjectEditMode();
    const hidden = loadHiddenProjects();

    // Add class to body
    document.body.classList.toggle("project-edit-mode", editMode);

    // Update checkboxes
    document
      .querySelectorAll<HTMLInputElement>("input.project-check")
      .forEach((cb) => {
        const id = cb.dataset.projectId;
        if (!id) return;

        // Show/hide checkbox in edit mode
        cb.classList.toggle("show-in-edit", editMode);

        // Checkbox reflects visibility
        cb.checked = !hidden.has(id);
      });

    // Update each project <li>
    document
      .querySelectorAll<HTMLLIElement>(".projects-li[data-project-id]")
      .forEach((li) => {
        const id = li.dataset.projectId;
        if (!id) return;

        const isHidden = hidden.has(id);

        // Hidden only when NOT in edit mode
        if (!editMode && isHidden) li.classList.add("hidden");
        else li.classList.remove("hidden");
      });

    setupProjectCheckboxListeners();
  }

  // ----------------------------
  // Checkbox handler
  // ----------------------------
  function onProjectCheckboxChange(this: HTMLInputElement) {
    const id = this.dataset.projectId;
    if (!id) return;

    const hidden = loadHiddenProjects();

    if (this.checked) hidden.delete(id);
    else hidden.add(id);

    saveHiddenProjects(hidden);
    applyProjectState();
  }

  function setupProjectCheckboxListeners() {
    document
      .querySelectorAll<HTMLLIElement>("input.project-check")
      .forEach((cb) => {
        cb.removeEventListener(
          "change",
          onProjectCheckboxChange as EventListener,
        );
        cb.addEventListener("change", onProjectCheckboxChange as EventListener);
      });
  }

  // ----------------------------
  // Public API (global)
  // ----------------------------
  (window as any).toggleProjectEditMode = function () {
    const enabled = !loadProjectEditMode();
    saveProjectEditMode(enabled);
    applyProjectState();
  };

  (window as any).enableProjectEditMode = function () {
    saveProjectEditMode(true);
    applyProjectState();
  };

  (window as any).disableProjectEditMode = function () {
    saveProjectEditMode(false);
    applyProjectState();
  };

  (window as any).setProjectVisibility = function (
    id: string,
    visible: boolean,
  ) {
    const hidden = loadHiddenProjects();

    if (visible) hidden.delete(String(id));
    else hidden.add(String(id));

    saveHiddenProjects(hidden);
    applyProjectState();
  };

  (window as any).toggleProject = function (id: string) {
    const hidden = loadHiddenProjects();

    if (hidden.has(String(id))) hidden.delete(String(id));
    else hidden.add(String(id));

    saveHiddenProjects(hidden);
    applyProjectState();
  };

  // ----------------------------
  // Initialize
  // ----------------------------
  window.addEventListener("DOMContentLoaded", applyProjectState);
</script>
